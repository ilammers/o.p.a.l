# O.P.A.L: Oscillated Projection of Adversarial Light 
+ This project focuses on creating dynamic, physically-possible adversarial examples targeting image classification networks. O.P.A.L is inspired by Dr. Yufeng Li and team's paper "Light can be Dangerous" where spot lights were used to create perturbations on road signs with consistent success. I wanted to expand upon this idea by creating patterns by projecting a laser onto the sign, as a high-powered laser would not have the same limitations as a spot light in terms of visibility. 
+ As a concept, O.P.A.L is designed to be deployable so that it can be tested in the field by researchers and manufacturers alike - running off of nothing but a drill battery and a Raspberry Pi. Once it is positioned in front of a sign, simply SSH into the Pi and run the fire.py payload to begin projecting, capturing, and classifying images. 
# Implementation: Overview and Theory
+ In modeling this project after "Light can be Dangerous" I decided to use the German Traffic Sign Recognition Benchmark, or GTSRB, as a base for this project. As I am in the United States, this was severely limiting in the long run as the only signs I could test on in the field were stop signs - the only identical image between German and US road signs. In hindsight I could have created to-scale prints of german road signs to test on in a controlled environment; however, actual road signs are reflective which would create discrepancies in replicating these attacks in the real world.
+ Why Tensorflow and not PyTorch? I had originally planned on using a Coral Edge TPU to run faster inferences on the Pi (only compatible with Tensorflow), this approach was scrapped however because the only working libraries for this chip are for Python 3.10 and I needed at least 3.11 to do what I needed with Keras. Without the TPU, inferences took about 4 seconds to run which was more than sufficient for my purposes and did not warrant re-writing the project for version 3.10. 
+ To create effective adversarial examples we need the distortion to cover either a wide surface area of the object in focus, or a critical piece of it. Li and Team's examples were actually just small circles projected at a specific area of the sign, my approach is a little more heuristic in practice. If the rule is to cover the image, then we need a method to generate distortions until a misclassification is produced. 
+ For projecting a distortion we have a mounted laser which bounces off of a mirror aimed toward the sign. To create patterns we simply just need to vibrate the mirror which we can do in a variety of ways. I ended up writing a method that takes two inputs (integer, representing hertz) and passes them to a sine function. I wanted to create static patterns and to do this we need to create a chord. In practice this just means multiplying a base frequency by a modifier for each tonal step (for a quarter step; mod2 must be .25 greater than mod1). 
